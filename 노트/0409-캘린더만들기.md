구글캘린더 클론


### 수정 코드드
React 프로젝트에서 **MySQL**과 **React-Big-Calendar**를 활용하여 캘린더 기능을 구현하려면, 다음 단계를 따르면 됩니다. 이 과정에서는 **React**를 프론트엔드로, **MySQL**을 백엔드 데이터베이스로 설정하며, 이를 API를 통해 연동합니다.

---

### 1. **프로젝트 초기화**
#### 필수 패키지 설치:
1. React-Big-Calendar와 관련 종속성 설치:
   ```bash
   npm install react-big-calendar moment date-fns
   ```
   - `react-big-calendar`: 캘린더 UI 라이브러리.
   - `moment` 또는 `date-fns`: 날짜/시간 처리 라이브러리.

2. MySQL과 API 서버를 위한 백엔드 라이브러리 설치:
   ```bash
   npm install express mysql2 cors
   ```
   - `express`: API 서버 구축.
   - `mysql2`: MySQL 데이터베이스 연결.
   - `cors`: React와 백엔드 간 Cross-Origin 문제 해결.

---

### 2. **백엔드(API) 설정**
MySQL에서 이벤트 데이터를 처리할 API 서버를 구축합니다.

#### 예제 코드 (`server.js`):
```javascript
const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
app.use(cors());
app.use(express.json());

const db = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'your_password',
    database: 'calendar_db',
});

// 이벤트 목록 가져오기
app.get('/events', (req, res) => {
    const sql = 'SELECT id, title, start, end FROM events';
    db.query(sql, (err, results) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(results);
    });
});

// 새로운 이벤트 추가
app.post('/events', (req, res) => {
    const { title, start, end } = req.body;
    const sql = 'INSERT INTO events (title, start, end) VALUES (?, ?, ?)';
    db.query(sql, [title, start, end], (err, result) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ id: result.insertId, title, start, end });
    });
});

app.listen(5000, () => {
    console.log('Server running on http://localhost:5000');
});
```

#### 이벤트 테이블 생성 SQL:
```sql
CREATE TABLE events (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    start DATETIME NOT NULL,
    end DATETIME NOT NULL
);
```

---

### 3. **React-Frontend 설정**
#### React-Big-Calendar 구성:
이제 `React-Big-Calendar`를 사용해 캘린더 UI를 구성합니다.

#### 캘린더 예제 컴포넌트:
```javascript
import React, { useEffect, useState } from 'react';
import { Calendar, momentLocalizer } from 'react-big-calendar';
import moment from 'moment';
import 'react-big-calendar/lib/css/react-big-calendar.css';

const localizer = momentLocalizer(moment);

const App = () => {
    const [events, setEvents] = useState([]);

    // 백엔드에서 이벤트 가져오기
    useEffect(() => {
        fetch('http://localhost:5000/events')
            .then((response) => response.json())
            .then((data) =>
                setEvents(
                    data.map((event) => ({
                        id: event.id,
                        title: event.title,
                        start: new Date(event.start),
                        end: new Date(event.end),
                    }))
                )
            )
            .catch((error) => console.error('Error fetching events:', error));
    }, []);

    return (
        <div style={{ height: '100vh' }}>
            <Calendar
                localizer={localizer}
                events={events}
                startAccessor="start"
                endAccessor="end"
                style={{ height: 500 }}
            />
        </div>
    );
};

export default App;
```

---

### 4. **React에서 이벤트 추가 기능 구현**
캘린더에서 새로운 이벤트를 추가할 수 있도록 폼과 API 연결을 추가합니다.

#### 폼 추가:
```javascript
import React, { useState } from 'react';

const AddEventForm = ({ onEventAdded }) => {
    const [title, setTitle] = useState('');
    const [start, setStart] = useState('');
    const [end, setEnd] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        const newEvent = { title, start, end };

        const response = await fetch('http://localhost:5000/events', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newEvent),
        });

        const data = await response.json();
        onEventAdded(data);
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="text"
                placeholder="Title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
            />
            <input
                type="datetime-local"
                value={start}
                onChange={(e) => setStart(e.target.value)}
                required
            />
            <input
                type="datetime-local"
                value={end}
                onChange={(e) => setEnd(e.target.value)}
                required
            />
            <button type="submit">Add Event</button>
        </form>
    );
};

export default AddEventForm;
```

#### 캘린더와 폼 결합:
```javascript
import React, { useEffect, useState } from 'react';
import { Calendar, momentLocalizer } from 'react-big-calendar';
import moment from 'moment';
import AddEventForm from './AddEventForm';
import 'react-big-calendar/lib/css/react-big-calendar.css';

const localizer = momentLocalizer(moment);

const App = () => {
    const [events, setEvents] = useState([]);

    useEffect(() => {
        fetch('http://localhost:5000/events')
            .then((response) => response.json())
            .then((data) =>
                setEvents(
                    data.map((event) => ({
                        id: event.id,
                        title: event.title,
                        start: new Date(event.start),
                        end: new Date(event.end),
                    }))
                )
            )
            .catch((error) => console.error('Error fetching events:', error));
    }, []);

    const handleEventAdded = (newEvent) => {
        setEvents((prevEvents) => [...prevEvents, newEvent]);
    };

    return (
        <div>
            <AddEventForm onEventAdded={handleEventAdded} />
            <div style={{ height: 500 }}>
                <Calendar
                    localizer={localizer}
                    events={events}
                    startAccessor="start"
                    endAccessor="end"
                    style={{ height: 500 }}
                />
            </div>
        </div>
    );
};

export default App;
```

---

### 5. **결론**
- **Backend (Express + MySQL)**: 이벤트 데이터를 저장 및 제공.
- **Frontend (React + React-Big-Calendar)**: UI에서 이벤트를 렌더링하고 추가/수정.

이렇게 하면 React-MySQL 프로젝트에서 `React-Big-Calendar`를 성공적으로 구현할 수 있습니다. 프로젝트에 따라 이벤트 수정, 삭제 등 기능을 추가할 수 있습니다. 더 깊은 구현이 필요하다면 알려주세요! 😊



------

## 날짜 클릭시 스케줄 추가할 수 있는 창


-------

스케줄 파일 안에 캘린더 컴포넌트를 넣고 캘린더 컴포넌트 안에서 리액트-빅-캘린더 라이브러리를 사용하는 중이라
클릭이벤트와 같은 이벤트를 어디에 선언해야하는지 모르겠어서 ai에게 물어봄

---

### 수정 코드 
`react-big-calendar`를 사용하는 경우, 클릭 이벤트나 일정 추가 이벤트와 같은 로직은 **`Calendar.jsx`**와 **`Scheduled.jsx`** 중 어디에 작성할지 결정해야 합니다. 이 결정은 **컴포넌트의 역할과 책임**에 따라 달라집니다.

---

### **컴포넌트 역할에 따른 분리**

1. **`Calendar.jsx` (프레젠테이션 컴포넌트)**:
   - 캘린더 UI를 렌더링하는 역할을 담당.
   - 캘린더의 기본 설정(`localizer`, `events`, `onSelectSlot` 등)을 처리.
   - 이벤트 핸들러는 `props`로 받아서 처리.

2. **`Scheduled.jsx` (컨테이너 컴포넌트)**:
   - 캘린더와 관련된 데이터 로직을 처리.
   - API 호출, 상태 관리, 이벤트 핸들러 정의.
   - Calendar.jsx에 필요한 데이터를 전달.

---

### **권장 구조**

- **이벤트 핸들러는 Scheduled.jsx에서 작성**:
  - Scheduled.jsx는 데이터 로직을 처리하므로, 클릭 이벤트나 일정 추가 이벤트를 여기서 정의하고, Calendar.jsx에 `props`로 전달합니다.
  - 이렇게 하면 Calendar.jsx는 UI 렌더링에만 집중할 수 있습니다.

---

### **구현 예시**

#### **1. Calendar.jsx (프레젠테이션 컴포넌트)**

Calendar.jsx는 캘린더 UI를 렌더링하고, 이벤트 핸들러를 `props`로 받아 처리합니다.

```jsx
import React from "react";
import { Calendar, momentLocalizer } from "react-big-calendar";
import moment from "moment";
import "../styled/react-big-calendar.scss";

const localizer = momentLocalizer(moment);

const CalendarComponent = ({ height, events, onSelectSlot, onSelectEvent }) => {
  return (
    <div style={{ height: height }}>
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        selectable // 드래그로 일정 추가 가능
        onSelectSlot={onSelectSlot} // 빈 공간 클릭/드래그 이벤트
        onSelectEvent={onSelectEvent} // 일정 클릭 이벤트
      />
    </div>
  );
};

export default CalendarComponent;
```

---

#### **2. Scheduled.jsx (컨테이너 컴포넌트)**

Scheduled.jsx에서 이벤트 핸들러를 정의하고, `CalendarComponent`에 전달합니다.

```jsx
import React, { useEffect, useState } from "react";
import CalendarComponent from "../components/Calendar.jsx";
import styled from "styled-components";
import C from "../styled/CalenderStyle.jsx";
import axios from "axios";
import moment from "moment";

const Scheduled = () => {
  const [sideCalendar, setSideCalendar] = useState(false);
  const [events, setEvents] = useState([]);

  // 백엔드에서 이벤트 가져오기
  const getEvent = async () => {
    await axios.get(`http://192.168.23.65:5000/sched/events`).then((res) => {
      setEvents(res.data);
    });
  };

  // 일정 추가 이벤트 핸들러
  const handleSelectNewData = ({ start, end }) => {
    const title = window.prompt("스케줄을 입력해주세요.");
    if (title) {
      const newEvent = {
        start: moment(start).toDate(),
        end: moment(end).toDate(),
        title,
      };

      // 로컬 상태 업데이트
      setEvents((prevEvents) => [...prevEvents, newEvent]);

      // 서버에 일정 추가 요청
      axios.post(`http://192.168.23.65:5000/sched/events`, newEvent).then(() => {
        console.log("새 일정이 추가되었습니다.");
      });
    }
  };

  // 일정 클릭 이벤트 핸들러
  const handleSelectEvent = (event) => {
    alert(`선택된 일정: ${event.title}`);
  };

  useEffect(() => {
    getEvent();
  }, []);

  return (
    <C.CalendarWrap $sideCalendar={sideCalendar}>
      {sideCalendar && (
        <C.SideContainer>
          <CalendarComponent height="300px" events={events} />
        </C.SideContainer>
      )}

      <C.ContentContainer>
        <CalendarComponent
          height="100%"
          events={events}
          onSelectSlot={handleSelectNewData} // 일정 추가 핸들러 전달
          onSelectEvent={handleSelectEvent} // 일정 클릭 핸들러 전달
        />
      </C.ContentContainer>
    </C.CalendarWrap>
  );
};

export default Scheduled;
```

---

### **핵심 로직 설명**

1. **`handleSelectNewData` (일정 추가 핸들러)**:
   - 사용자가 캘린더의 빈 공간을 클릭하거나 드래그하면 호출됩니다.
   - `window.prompt`로 일정 제목을 입력받아 새로운 이벤트를 생성합니다.
   - 로컬 상태(`events`)를 업데이트하고, 서버에 추가 요청을 보냅니다.

2. **`handleSelectEvent` (일정 클릭 핸들러)**:
   - 사용자가 이미 추가된 일정을 클릭하면 호출됩니다.
   - 클릭된 일정의 정보를 표시하거나, 수정/삭제 로직을 추가할 수 있습니다.

3. **`getEvent` (이벤트 가져오기)**:
   - 서버에서 기존 일정을 가져와 `events` 상태에 저장합니다.

4. **`CalendarComponent`에 이벤트 핸들러 전달**:
   - `onSelectSlot`과 `onSelectEvent`를 `CalendarComponent`의 `props`로 전달하여 캘린더에서 이벤트를 처리합니다.

---

### **결론**

- **`Calendar.jsx`**:
  - 캘린더 UI를 렌더링하고, 이벤트 핸들러를 `props`로 받아 처리합니다.
  - 캘린더의 역할에만 집중합니다.

- **`Scheduled.jsx`**:
  - 데이터 로직(일정 추가, 삭제, 수정 등)을 처리하고, 이벤트 핸들러를 정의합니다.
  - Calendar.jsx에 필요한 데이터를 전달합니다.

이 구조를 사용하면 컴포넌트의 역할이 명확히 분리되어 유지보수와 확장이 용이해집니다.

----

위의 코드를 넣었을 때 스케줄라우터

```jsx
  // 캘린더 관련 라우트

  import express from "express";
  import util from "util";
  import { query } from "../helpers/dbHelper.js";

  const router = express.Router();

  router.get("/", (req, res) => {
    res.send("auth");
  });

  // 이벤트 목록 가져오기
  router.get("/events", (req, res) => {
    const sql = "SELECT id, title, start, end FROM events";
    query(sql)
      .then((data) => {
        res.send(data);
      })
      .catch((err) => {
        res.send(err);
      });
  });

  // 새로운 이벤트 추가
  router.post('/events', (req, res) => {
    const { title, start, end } = req.body;
    console.log("req.body", req.body,'title, start, end',title, start, end);
    
    const sql = 'INSERT INTO events (title, start, end) VALUES (?, ?, ?)';

    query(sql,[title, start,end])
    .then((data) => res.send(data))
    .catch((err) => res.send(err));
  });


  export default router;
```
----

위처럼 작성했을 때 DB로 보내주는 날짜 값이    
```'2025-04-17T15:00:00.000Z'``` 이런 식으로 작성되어서 데이터 전달이 되지않음   
```'yyyy-mm-dd hh:mm:ss'``` 해당 형식으로 변경해야함


---
### 수정 코드   
`'2025-04-01T15:00:00.000Z'`와 같은 ISO 8601 형식의 날짜를 데이터베이스에 저장 가능한 `'yyyy-mm-dd hh:mm:ss'` 형식으로 변환하려면, JavaScript의 `Date` 객체와 `moment` 라이브러리(또는 `Intl.DateTimeFormat` 등)를 사용할 수 있습니다.

---

### **해결 방법**

`moment` 라이브러리를 사용하여 날짜를 변환하는 방법을 예로 들어 설명하겠습니다.

---

### **수정된 코드**

#### **1. `moment` 라이브러리 설치**
`moment` 라이브러리가 프로젝트에 설치되어 있지 않다면, 아래 명령어로 설치합니다.

```bash
npm install moment
```

#### **2. schedRoutes.js 수정**

`start`와 `end` 값을 `'yyyy-mm-dd hh:mm:ss'` 형식으로 변환한 후 데이터베이스에 저장합니다.

```javascript
import express from "express";
import moment from "moment"; // moment 라이브러리 추가
import { query } from "../helpers/dbHelper.js";

const router = express.Router();

// 새로운 이벤트 추가
router.post("/events", (req, res) => {
  const { title, start, end } = req.body;

  // 날짜 형식 변환
  const formattedStart = moment(start).format("YYYY-MM-DD HH:mm:ss");
  const formattedEnd = moment(end).format("YYYY-MM-DD HH:mm:ss");

  console.log("Formatted Dates:", formattedStart, formattedEnd);

  const sql = "INSERT INTO events (title, start, end) VALUES (?, ?, ?)";

  query(sql, [title, formattedStart, formattedEnd])
    .then((data) => res.send(data))
    .catch((err) => res.status(500).send(err));
});

export default router;
```

---

### **코드 설명**

1. **`moment(start).format("YYYY-MM-DD HH:mm:ss")`**:
   - `start`와 `end` 값을 `moment`를 사용하여 `'yyyy-mm-dd hh:mm:ss'` 형식으로 변환합니다.
   - 예: `'2025-04-01T15:00:00.000Z'` → `'2025-04-01 15:00:00'`.

2. **변환된 값 사용**:
   - 변환된 `formattedStart`와 `formattedEnd` 값을 SQL 쿼리에 전달하여 데이터베이스에 저장합니다.

3. **`console.log`로 디버깅**:
   - 변환된 날짜 값이 올바른지 확인하기 위해 `console.log`를 추가했습니다.

---

### **결과**

- **입력 데이터**:
  ```json
  {
    "title": "회의",
    "start": "2025-04-01T15:00:00.000Z",
    "end": "2025-04-01T16:00:00.000Z"
  }
  ```

- **변환된 데이터**:
  - `start`: `'2025-04-01 15:00:00'`
  - `end`: `'2025-04-01 16:00:00'`

- **데이터베이스에 저장된 값**:
  ```sql
  INSERT INTO events (title, start, end) VALUES ('회의', '2025-04-01 15:00:00', '2025-04-01 16:00:00');
  ```

---

### **추가 고려 사항**

1. **타임존 처리**:
   - `moment`는 기본적으로 UTC를 기준으로 작동합니다. 만약 로컬 타임존으로 변환해야 한다면, `moment-timezone`을 사용할 수 있습니다.
   - 예:
     ```javascript
     const formattedStart = moment(start).tz("Asia/Seoul").format("YYYY-MM-DD HH:mm:ss");
     ```

2. **`moment` 대체 라이브러리**:
   - `moment`는 무겁기 때문에, 더 가벼운 라이브러리인 `date-fns`를 사용할 수도 있습니다.
   - 예:
     ```javascript
     import { format } from "date-fns";

     const formattedStart = format(new Date(start), "yyyy-MM-dd HH:mm:ss");
     ```

3. **SQL 데이터 타입 확인**:
   - 데이터베이스의 `start`와 `end` 컬럼이 `DATETIME` 또는 `TIMESTAMP` 타입인지 확인하세요. 그렇지 않으면 저장 시 문제가 발생할 수 있습니다.

---

이 코드를 적용하면, ISO 8601 형식의 날짜를 데이터베이스에서 사용할 수 있는 `'yyyy-mm-dd hh:mm:ss'` 형식으로 변환하여 저장할 수 있습니다.

---

## 현재 캘린더에 일정 추가 기능까지 구현되었고, 프롬포트 창으로 일정추가하는걸 팝업? 으로 수정하기

다이얼로그 창 나오는 위치는 사용자 클릭 옆으로


- 엔터나 버튼으로 저장

onChange로 인풋 값 저장하고
saveBtn 클릭 시 scheduled 컴포넌트로 인풋 값 보내주기
저장된 값 받아와서 서버로 보내기

캘린더에서 저장됨을 알리는 함수 보내기

-----

스타일 컴포넌트 
`styled-components`에서 `props`를 통해 전달된 값을 스타일에 반영하려면, 스타일 정의 내에서 함수 형태로 `props`를 사용할 수 있습니다. `C.Content`에서 넘기는 `$labels` 값을 스타일 컴포넌트에서 사용하는 방법은 아래와 같습니다.

---

### **방법: `props`를 사용하여 `$labels` 접근**

`styled-components`는 컴포넌트에 전달된 `props`를 스타일 정의에서 사용할 수 있도록 지원합니다. `$labels`는 `props`로 전달되므로, 이를 스타일 정의에서 접근하여 사용할 수 있습니다.

---

### **수정된 코드**

#### **1. `C.Content`에서 `$labels` 전달**

DialogComponent.jsx에서 `$labels`를 `C.Content`에 전달하고 있습니다. 이 부분은 그대로 유지합니다.

```jsx
<C.Content $labels={labels}>
  <div className="label">
    <ul>
      <li className="pink active"></li>
      <li className="green"></li>
      <li className="blue"></li>
      <li className="yellow"></li>
    </ul>
  </div>
</C.Content>
```

---

#### **2. CalenderStyle.jsx에서 `$labels` 사용**

`styled-components`에서 `$labels`를 사용하려면, 스타일 정의 내에서 `props`를 함수로 받아 처리합니다.

```jsx
const Content = styled.div`
  .label {
    display: flex;
    gap: 10px;
    margin-top: 20px;

    > ul {
      display: flex;
      gap: 5px;
      list-style: none;
      padding-left: 0px;

      > li {
        width: 20px;
        height: 20px;
        border-radius: 50%;

        /* $labels를 사용하여 동적으로 스타일 적용 */
        /* 배열을 받아와야함 */
        ${({ $labels }) =>
          $labels &&
          $labels.map(
            (label) => `
              &.${label.name} {
                background-color: ${label.color};
              }
            `
          )}

        &.active {
          transform: scale(1.2);
          box-shadow: 0px 0px 5px rgb(0 0 0 / 44%);
        }
      }
    }
  }
`;
```

---

### **코드 설명**

1. **`$labels`를 `props`로 전달**:
   - `C.Content`에 `$labels`를 전달합니다.
   - `$labels`는 배열 형태로 전달되며, 각 객체는 `name`과 `color` 속성을 포함합니다.

   ```javascript
   const labels = [
     { name: "pink", color: "#ff7eb3" },
     { name: "green", color: "#a2ab58" },
     { name: "blue", color: "#66a6ff" },
     { name: "yellow", color: "#f7b733" },
   ];
   ```

2. **`styled-components`에서 `$labels` 사용**:
   - `styled-components`는 `props`를 함수로 받아 처리할 수 있습니다.
   - `map`을 사용하여 `$labels` 배열의 각 항목에 대해 동적으로 스타일을 생성합니다.

   ```javascript
   ${({ $labels }) =>
     $labels &&
     $labels.map(
       (label) => `
         &.${label.name} {
           background-color: ${label.color};
         }
       `
     )}
   ```

3. **동적 클래스 스타일링**:
   - 각 `li` 요소는 `className`으로 `pink`, `green`, `blue`, `yellow`를 가질 수 있습니다.
   - `$labels` 배열의 `name`과 `color`를 기반으로 해당 클래스에 스타일을 적용합니다.

---

### **결과**

1. **`$labels`에 따라 동적 스타일 적용**:
   - `$labels` 배열에 정의된 `name`과 `color`를 기반으로 각 `li` 요소에 스타일이 적용됩니다.
   - 예: `className="pink"`인 요소는 `background-color: #ff7eb3`가 적용됩니다.

2. **`active` 클래스 스타일 유지**:
   - `active` 클래스는 기존 스타일(`transform: scale(1.2)` 등)을 유지합니다.

---

### **추가 고려 사항**

1. **`$labels`가 없는 경우**:
   - `$labels`가 전달되지 않을 경우를 대비해 기본값을 설정하거나 조건부로 처리합니다.

   ```javascript
   ${({ $labels }) =>
     $labels &&
     $labels.map(
       (label) => `
         &.${label.name} {
           background-color: ${label.color};
         }
       `
     )}
   ```

2. **성능 최적화**:
   - `$labels` 배열이 매우 크다면, 스타일 생성이 성능에 영향을 줄 수 있습니다. 이 경우, 스타일을 미리 정의하거나 캐싱하는 방법을 고려할 수 있습니다.

---

이 코드를 적용하면 `C.Content`에서 전달된 `$labels` 값을 기반으로 동적으로 스타일을 적용할 수 있습니다.

---------

## 사이드 캘린더에서 날짜 클릭 시 메인 캘린더에서 클릭한 날의 데이 페이지로 보여주기

`sideContainer`의 캘린더에서 날짜를 클릭했을 때, `contentContainer`에 있는 메인 캘린더가 `sideContainer`에서 클릭한 날짜의 `day` 뷰로 전환되도록 구현하려면, `sideContainer`의 캘린더에서 날짜 클릭 이벤트를 처리하고, 이를 부모 컴포넌트(`Scheduled`)로 전달하여 `contentContainer`의 캘린더 상태를 업데이트해야 합니다.

---

### **구현 방법**

1. **`sideContainer`에서 날짜 클릭 이벤트 처리**:
   - `onSelectSlot` 핸들러를 사용하여 클릭한 날짜를 부모 컴포넌트로 전달합니다.

2. **부모 컴포넌트에서 상태 업데이트**:
   - `contentContainer`의 캘린더 상태(`date`와 `view`)를 업데이트합니다.

3. **`contentContainer`의 캘린더 업데이트**:
   - 부모 컴포넌트에서 전달받은 상태를 기반으로 `contentContainer`의 캘린더를 업데이트합니다.

---

### **수정된 코드**

#### **1. `Scheduled` 컴포넌트 수정**

`sideContainer`에서 날짜를 클릭했을 때, `contentContainer`의 캘린더 상태를 업데이트하도록 수정합니다.

```jsx
const Scheduled = () => {
  const [events, setEvents] = useState([]);
  const [emptyEvents, setEmptyEvents] = useState([]);
  const [handleDate, setHandleDate] = useState(new Date()); // contentContainer의 날짜 상태
  const [currentView, setCurrentView] = useState("month"); // contentContainer의 뷰 상태
  const [viewDate, setViewDate] = useState(new Date()); // sideContainer의 날짜 상태

  // sideContainer에서 날짜 클릭 시 contentContainer의 상태 업데이트
  const handleSideDateClick = (date) => {
    setHandleDate(date); // contentContainer의 날짜를 업데이트
    setCurrentView("day"); // contentContainer의 뷰를 day로 변경
  };

  return (
    <C.Wrap $events={events}>
      <C.CalendarWrap>
        {sideCalendar && (
          <C.SideContainer className="side-container">
            <CalendarComponent
              height="300px"
              events={emptyEvents}
              date={viewDate}
              view="month"
              toolbar={ToolbarMini}
              onSelectSlot={({ start }) => handleSideDateClick(start)} // 날짜 클릭 시 처리
              onSelectEvent={() => {}} // 이벤트 클릭 시 아무 동작도 하지 않음
            />
          </C.SideContainer>
        )}

        <C.ContentContainer>
          <CalendarComponent
            height="100%"
            events={events}
            setEvents={setEvents}
            onSelectSlot={() => {}}
            onSelectEvent={() => {}}
            date={handleDate} // 업데이트된 날짜 전달
            view={currentView} // 업데이트된 뷰 전달
            toolbar={ToolbarComponent}
            popup={true}
          />
        </C.ContentContainer>
      </C.CalendarWrap>
    </C.Wrap>
  );
};

export default Scheduled;
```

---

#### **2. `CalendarComponent` 수정**

`CalendarComponent`는 부모로부터 전달받은 `date`와 `view`를 사용하여 캘린더를 렌더링합니다. 추가 수정은 필요하지 않습니다.

---

### **코드 설명**

1. **`handleSideDateClick`**:
   - `sideContainer`의 캘린더에서 날짜를 클릭했을 때 호출됩니다.
   - 클릭한 날짜를 `handleDate`로 설정하고, `currentView`를 `"day"`로 변경합니다.

2. **`onSelectSlot`**:
   - `sideContainer`의 캘린더에서 날짜를 클릭했을 때 호출됩니다.
   - 클릭한 날짜(`start`)를 `handleSideDateClick`에 전달합니다.

3. **`contentContainer`의 캘린더**:
   - `handleDate`와 `currentView`를 사용하여 클릭한 날짜와 `day` 뷰로 전환됩니다.

---

### **결과**

1. `sideContainer`의 캘린더에서 날짜를 클릭하면, `contentContainer`의 캘린더가 해당 날짜의 `day` 뷰로 전환됩니다.
2. `sideContainer`는 여전히 `month` 뷰를 유지합니다.
3. `contentContainer`는 클릭한 날짜와 `day` 뷰를 기반으로 업데이트됩니다.