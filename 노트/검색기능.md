`ad`를 검색했을 때 `admin`이나 `ad`가 포함된 모든 아이디를 검색하려면, SQL 쿼리에서 `LIKE` 절을 사용해야 합니다. `LIKE` 연산자를 사용하면 특정 문자열을 포함하는 데이터를 검색할 수 있습니다. 와일드카드 `%`를 함께 사용하면 `ad`가 포함된 모든 결과를 반환할 수 있습니다.

---

### 수정된 코드:
아래는 `LIKE` 조건을 사용한 수정된 `router.post("/search")` 코드입니다:

```javascript
router.post("/search", (req, res) => {
  const searchVal = req.body.search;
  console.log("사용자 검색", searchVal);

  // 검색 조건에서 LIKE를 사용하여 부분 문자열을 매칭
  const sql = `SELECT * FROM user WHERE id LIKE ?`;

  // '%검색값%' 형태로 와일드카드 추가
  query(sql, [`%${searchVal}%`])
    .then((data) => {
      if (data.length > 0) {
        console.log("값 있음");
        res.send({ result: data }); // 검색 결과 반환
      } else {
        console.log("값 없음, 전체 사용자 정보 반환");
        const allUsersSql = "SELECT * FROM user"; // 모든 사용자 가져오기 쿼리
        query(allUsersSql)
          .then((allData) => {
            res.send({ msg: "검색하신 내용이 없습니다.", result: allData }); // 전체 데이터 반환
          })
          .catch((err) => {
            console.error("전체 사용자 정보 가져오기 실패:", err);
            res.status(500).send({
              msg: "전체 사용자 정보를 가져오는 데 실패했습니다.",
              error: err,
            });
          });
      }
    })
    .catch((err) => {
      console.error("쿼리 실행 중 오류 발생:", err);
      res.status(500).send({ msg: "쿼리 실행 실패", error: err });
    });
});
```

---

### 주요 변경 사항:
1. **`LIKE` 절 사용**:
   ```sql
   SELECT * FROM user WHERE id LIKE ?
   ```
   - `id` 컬럼에서 `searchVal` 값이 포함된 데이터를 검색합니다.
   - `?`에 전달된 값은 와일드카드 `%`를 사용하여 `'%검색값%'` 형태로 매칭됩니다.

2. **와일드카드 `%` 추가**:
   ```javascript
   [`%${searchVal}%`]
   ```
   - SQL 쿼리에 전달할 검색 값을 와일드카드와 함께 사용하여 부분 매칭을 허용합니다.
   - 예: `ad`를 검색하면 `'%ad%'`로 변환되어 `admin`, `adventure`, `abcd` 등이 검색됩니다.

3. **에러와 결과 처리 유지**:
   - 검색 결과가 없을 경우 전체 사용자 정보를 반환하도록 로직을 그대로 유지했습니다.

---

### 동작 예시:
- 사용자가 `ad`를 검색하면, 아래와 같은 데이터가 반환됩니다:
  ```sql
  SELECT * FROM user WHERE id LIKE '%ad%';
  ```
  - 결과: `["admin", "adventure", "abcd"]`

- 검색 결과가 없으면 모든 사용자 데이터를 반환합니다:
  ```sql
  SELECT * FROM user;
  ```

---

### 보안 주의 사항:
- **SQL Injection 방지**:
  - `query` 함수에서 `?`와 배열(`[%${searchVal}%]`)을 사용해 값이 안전하게 바인딩되도록 처리합니다.
  - 이 방법은 직접 문자열을 쿼리에 삽입하는 방식을 피하므로 SQL Injection 공격을 방지할 수 있습니다.

- **페이징 처리**:
  - 전체 사용자 데이터를 반환할 때 데이터가 많을 경우 서버에 부하가 걸릴 수 있습니다. 페이징 처리(`LIMIT`와 `OFFSET`)를 통해 반환되는 데이터 양을 제한하세요:
    ```sql
    SELECT * FROM user LIMIT 10 OFFSET 0;
    ```

---

### 개선 방안 적용 후:
이 코드는 검색어가 포함된 결과를 반환하며, 결과가 없을 경우 전체 데이터를 반환하는 동작을 제공합니다. 테스트해보시고 문제가 있으면 언제든 문의해주세요! 😊



=====

전체 칼럼에서 검색으로 수정

SQL에서 특정 컬럼(예: `title`)만 검색하지 않고 **전체 칼럼**에서 검색하려면 **CONCAT** 또는 **FULLTEXT 검색**을 활용할 수 있습니다. 아래는 두 가지 방법을 설명합니다.

---

### **1. CONCAT을 활용한 전체 칼럼 검색**
`CONCAT`를 사용하면 여러 컬럼을 하나로 합쳐서 검색할 수 있습니다. 이 방법은 전체 텍스트 데이터를 대상으로 부분 문자열을 검색할 때 사용할 수 있습니다.

#### 수정된 SQL:
```sql
SELECT * FROM board
WHERE CONCAT(title, subTitle, customer, pm1, pm2, pm3, etc) LIKE ?
ORDER BY idx DESC
LIMIT 0, 10;
```

#### 설명:
- `CONCAT` 함수는 `title`, `subTitle`, `customer` 등 모든 컬럼의 데이터를 하나로 결합합니다.
- `LIKE` 조건을 사용하여 결합된 데이터에서 부분 문자열을 검색합니다.
- 이 방식은 간단하지만 데이터베이스 성능에 영향을 줄 수 있으므로 **데이터가 많은 경우 최적화를 고려**해야 합니다.

---

### **2. FULLTEXT 검색 (MySQL의 전문 텍스트 검색 기능)**
MySQL에서는 `FULLTEXT` 검색을 사용해 전체 텍스트를 효율적으로 검색할 수 있습니다. 이 방법은 성능이 뛰어나며, 큰 데이터셋에서도 빠른 검색이 가능합니다.

#### FULLTEXT 인덱스 생성:
먼저, `board` 테이블에 `FULLTEXT` 인덱스를 추가해야 합니다.
```sql
ALTER TABLE board ADD FULLTEXT(title, subTitle, customer, pm1, pm2, pm3, etc);
```

#### 수정된 SQL:
```sql
SELECT * FROM board
WHERE MATCH(title, subTitle, customer, pm1, pm2, pm3, etc) AGAINST(? IN BOOLEAN MODE)
ORDER BY idx DESC
LIMIT 0, 10;
```

#### 설명:
- `MATCH`와 `AGAINST`를 사용하여 지정한 컬럼들의 텍스트 데이터를 검색합니다.
- **BOOLEAN MODE**를 사용하면 `+`, `-`, `*` 같은 연산자를 활용하여 더 정교한 검색을 수행할 수 있습니다.
- 이 방법은 효율적이며 대규모 데이터베이스에서도 적합합니다.

---

### **비교**
| **방법**            | **장점**                                    | **단점**                                      |
|---------------------|---------------------------------------------|-----------------------------------------------|
| **CONCAT + LIKE**   | - 설정이 간단하고 모든 DB에서 사용 가능       | - 대량 데이터에서 속도가 느림                  |
| **FULLTEXT 검색**   | - 대규모 데이터에서도 성능이 뛰어남           | - 인덱스 생성 필요<br>- 일부 DB에서만 지원 (MySQL 등) |

---

### **추천**
1. **데이터가 많고 성능이 중요한 경우**: FULLTEXT 검색을 사용하는 것이 최적입니다.
2. **간단한 테스트나 소규모 데이터베이스**: CONCAT과 LIKE를 활용하세요.
