이 오류는 `multer` 패키지가 프로젝트에 설치되지 않았거나, 올바르게 설치되지 않아 발생합니다. React나 Node.js 프로젝트에서 `multer`를 사용하는 경우, 아래 단계를 통해 문제를 해결할 수 있습니다.

---

### **1. `multer` 설치 확인**
먼저, `multer`가 프로젝트에 설치되어 있는지 확인하세요. 프로젝트 폴더에서 다음 명령어를 실행하여 패키지 설치 상태를 확인합니다:

```bash
npm list multer
```

#### 결과:
- 만약 `multer`가 나열되지 않거나 오류가 발생한다면, 패키지가 설치되지 않은 상태입니다.

---

### **2. `multer` 설치**
`multer`가 설치되지 않은 경우, 아래 명령어를 실행하여 패키지를 설치합니다:

```bash
npm install multer
```

#### 설치 완료 후 다시 확인:
```bash
npm list multer
```

설치가 완료되었으면, 패키지가 프로젝트에 포함된 것을 확인할 수 있습니다.

---

### **3. 올바르게 `import` 사용**
`multer` 패키지를 사용하는 코드에서 `require` 또는 `import`가 올바르게 설정되어 있는지 확인하세요.

#### Node.js 예시 (`require` 사용):
```javascript
const multer = require('multer');
```

#### ES6 스타일 (`import` 사용):
```javascript
import multer from 'multer';
```

---

### **4. `node_modules` 문제 확인**
설치 후에도 동일한 오류가 발생한다면, `node_modules` 폴더가 손상되었을 가능성이 있습니다. 이를 해결하려면 다음 명령어를 실행해 패키지를 다시 설치하세요:

```bash
rm -rf node_modules package-lock.json
npm install
```

---

### **5. 프로젝트 폴더 확인**
`multer`를 사용하려는 프로젝트의 현재 디렉토리가 정확한지 확인하세요. `npm install multer` 명령어는 현재 폴더의 `package.json` 파일에 패키지를 추가하므로, 올바른 디렉토리에서 작업해야 합니다.

---

### **6. 기타 문제 해결**
- **의존성 충돌**: 특정 Node.js 버전과 호환되지 않는 패키지가 설치되어 있을 수 있습니다. Node.js 버전을 확인하고 업데이트하세요.
  ```bash
  node -v
  ```

- **타이핑 오류**: `multer` 이름을 잘못 입력한 경우 (`Multer`, `muler` 등), 올바른 이름을 사용했는지 확인하세요.

---


그리고 아래에 
*이미지 등록시 기존이미지 삭제 됩니다.
수정 페이지에서 등록 이미지 미리보기
이미지 수정 시에는 처음 등록한 파일명으로 덮어씌우기 가능한지 확인하기
=> 4.3 완료. 화면전환 수정해야함 // 수정완료

====

리스트 더보기 

더보기에서 리스트 보내줄 때는
offset이 isOffset 값 / 0 을 받아야하고
limit 값이 누적된 offset 값을 받아야함 

인덱스 언디파인드 일 때 불러오는건 디테일에서만 인지 확인하고 코드 수정하기


// 디자인 수정

----
4.4

이미지 파일명이 덮어쓰기 되는거라
1번 게시물과 n번의 게시물의 썸네일 파일명이 동일할 경우 1번 게시물에도 덮어지게 됨.. 둘이 같은 썸네일 파일을 공유하게 됨
파일명을 저장할 때 게시물의 인덱스 번호나 고유 키 값을 붙여야할듯

-> 수정 시에는 인덱스 값을 보내준까 문제는 없는데. 새로 등록하는 과정의 인덱스를 몰라서 언디파인드_파일명 으로 넘어감
새로 등록하게 되는 과정의 인덱스 값을 알아야함


가장 최신 데이터의 인덱스 + 1 ??

## 완성

### 문제
이미지 파일명이 덮어쓰기 되는 중이라 예를 들어 1번 과정 이미지와 n번째의 과정 이미지 파일명이 동일할 경우 두개 또는 n개의 과정 이미지가 함께 수정됨.   
해당 문제를 해결하기 위해 저장되는 파일명에 과정 인덱스를 붙이고자 함.

### 과정
수정 시에는 인덱스 값을 보내고 있어서 원하는 대로 작동하는데 새로 등록되는 과정에는 인덱스 값이 지정되지 않아서 undefined로 넘어가게 됨.   
새로 등록하게 되는 과정의 인덱스 값을 미리 알아야함.

### 해결
boardRoutes.js 파일만 수정함   
**업로드 라우트 핸들러 함수**
라우트 핸들러에서 index라는 변수를 선언하고 초기 값은 req.body.idx로 정의했다
```jsx
const { base64Image, originalName, idx } = req.body;
let index = req.body.idx; // 쿼리 파라미터에서 idx 가져오기
```

이후에 if 문에서 쿼리문을 사용하여 마지막으로 등록된 데이터 값을 받아오도록 수정했다.

```jsx
if (index === undefined) {
    console.log('인덱스 값을 재정의 해줘야 undefined');
    const sqlDESC = `SELECT * FROM board ORDER BY idx DESC LIMIT 0, 1`;
    query(sqlDESC).then((data) => {
      // res.send(data)
      console.log("가장 최근 인덱스 값", data[0].idx);
      index = data[0].idx + 1; // 가장 최근 인덱스 값에 1을 더하여 사용
    });

    console.log('index 인덱스 값 재정의', index);
    
  };
  console.log('index 인덱스 값 재정의 22', index);
```
이렇게 수정 시에는 'index 인덱스 값 재정의 22' 해당 콘솔이 먼저 나오게 되어서 async을 추가했다.

```jsx
router.post("/upload", async (req, res) => {
  const { base64Image, originalName, idx } = req.body;
  let index = req.body.idx; // 쿼리 파라미터에서 idx 가져오기

  if (index === undefined) {
    const sqlDESC = `SELECT * FROM board ORDER BY idx DESC LIMIT 0, 1`;

    try {
      const data = await query(sqlDESC); // 비동기 작업
      if (data.length > 0) {
        console.log("가장 최근 인덱스 값", data[0].idx);
        index = data[0].idx + 1; // 가장 최근 인덱스 값에 1을 더하여 사용
      } else {
        index = 1; // 테이블이 비어 있는 경우 기본값 설정
      }
      console.log("index 인덱스 값 재정의", index);
    } catch (error) {
      console.error("인덱스 값을 가져오는 중 오류 발생:", error);
      return res.status(500).send({ msg: "인덱스 값을 가져오는 중 오류 발생" });
    }
  };
});
```
완성된 코드의 if 문 부분이다.


----
### 해결되지 않은 문제

24번 까지는 순차적으로 쌓인 게시물이고 24번 부터 32번까지의 게시물을 삭제한 후에 새로 과정을 등록할 경우 인덱스는 33번으로 생성되는데   
가장 최근의 인덱스 값에 1을 더하는 중이라 새로 등록되는 과정의 인덱스는 25번으로 정의되고, 저장되는 데이터의 실제 인덱스 값은 33번이 저장된다.   
<br/>
수정하기 귀찮아서 ai 한테 추후에 문제가 있을지 물어보니까 수정을 제시한다.
<br/>

ai의 대답...   
```md
삭제된 인덱스를 재활용하여 이후의 게시물이 해당 인덱스를 가지도록 설계할 경우, **데이터 무결성과 시스템 동작** 측면에서 잠재적인 문제가 발생할 수 있습니다. 아래는 이를 도입했을 때 주의해야 할 점과 발생할 가능성이 있는 문제들을 정리했습니다:

---

### 1. **데이터 무결성 문제**
- **참조 무결성 깨짐**:
  데이터베이스에서 다른 테이블이 삭제된 게시물의 인덱스를 참조하고 있다면, 인덱스를 재사용하는 순간 참조가 잘못될 수 있습니다.
  - 예: 댓글 또는 로그 테이블에서 `FOREIGN KEY`로 게시물 ID를 참조하고 있는 경우.
  - 해결 방안: 참조된 데이터가 깨지지 않도록 모든 연결된 데이터를 함께 삭제하거나 관계를 수정해야 합니다.

- **히스토리 추적 문제**:
  동일한 인덱스를 가진 여러 게시물 데이터가 존재했던 기록이 남아 혼란을 초래할 수 있습니다. 특히 데이터 변경 이력을 기록하는 시스템에서는 중요한 문제가 될 수 있습니다.

---

### 2. **사용자 경험(UX) 혼란**
- **게시물 URL 충돌**:
  사용자가 게시물에 접근할 때, URL이 인덱스 기반으로 만들어져 있다면(예: `/post/25`), 삭제된 게시물이 아닌 새로운 게시물로 리디렉션되면서 사용자가 혼란을 겪을 수 있습니다.

- **예기치 않은 결과**:
  관리자가 과거 게시물을 식별하거나 복원하려 할 때, 동일한 인덱스가 재사용됨으로 인해 정확한 데이터를 찾기 어려워질 수 있습니다.

---

### 3. **데이터베이스 성능 문제**
- **AUTO_INCREMENT 동작 충돌**:
  수동으로 인덱스를 재설정하면 `AUTO_INCREMENT`의 기본 동작과 충돌할 수 있습니다. MySQL은 항상 최대값 + 1을 새 인덱스로 할당하려고 하므로, 재사용된 값과 충돌이 발생하면 오류가 날 수 있습니다.
  - 예: `INSERT` 시 `Duplicate entry` 오류.

- **복잡한 관리 로직 필요**:
  삭제된 인덱스를 추적하고 재사용하기 위한 추가 로직이 필요하며, 이는 시스템의 복잡성을 증가시키고 성능 저하를 유발할 수 있습니다.

---

### 4. **보안 및 감사 문제**
- **감사(Audit) 및 로그 분석**:
  로그 시스템에서 동일한 인덱스를 가진 다른 게시물들이 기록될 경우, 누가 어떤 게시물을 등록/삭제했는지 정확히 추적하기 어렵습니다.
  - 해결 방안: 인덱스 재사용 대신, 게시물 상태를 '비활성화'로 표시하고 삭제하지 않는 방식 고려.

- **인덱스 추정 공격에 대한 위험 증가**:
  해커가 ID 기반으로 시스템의 특정 게시물에 접근하려고 시도할 때, 삭제된 게시물의 ID가 재사용되면 공격자의 추정이 더 쉬워질 수 있습니다.

---

### 대안적인 해결 방법
삭제된 인덱스를 재사용하는 대신, 다음과 같은 방법을 고려할 수 있습니다:

1. **논리적 삭제(Logical Deletion)**:
   - 데이터를 물리적으로 삭제하지 않고, 삭제된 상태임을 나타내는 플래그(`is_deleted`)를 설정합니다.
     ```sql
     UPDATE posts SET is_deleted = 1 WHERE id = 25;
     ```

2. **빈 자리를 추적하되 무작위 ID 할당**:
   - 삭제된 인덱스를 추적하더라도, 외부적으로는 무작위 UUID 또는 고유한 값을 사용합니다.

3. **기존의 AUTO_INCREMENT 유지**:
   - 단순히 새 게시물이 항상 새로운 ID를 가지도록 하여 데이터 무결성을 보장합니다.

---

결론적으로, 삭제된 인덱스를 재사용할 때는 데이터베이스의 무결성과 시스템 안정성에 심각한 영향을 미칠 수 있으므로, 신중하게 고려하고 대안을 설계하는 것이 중요합니다. 추가적인 구현 방법이나 궁금증이 있다면 말씀해 주세요! 😊
```

---
```jsx
const sqlIdx = `
    SELECT AUTO_INCREMENT
    FROM INFORMATION_SCHEMA.TABLES
    WHERE TABLE_SCHEMA = ?
    AND TABLE_NAME = ?;
  `;
```
해당 쿼리문으로는 재설정된 ```AUTO_INCREMENT```을 가져오지 않음


이미지가 먼저 업로드 된 후에 게시물이 저장됨.

지금까지 저장된 인덱스 값을 모두 저장해둘 수 있나
지금까지 50개의 게시물이 저장되었으면
하나의 변수에 50이 카운팅 되어있고,
해당 변수에 +1이 새로 등록될 게시물의 인덱스 값이 되도록

그냥 얼렁뚱땅 해결하고 포기함
